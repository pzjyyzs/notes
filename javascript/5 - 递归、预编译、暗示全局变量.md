# 递归
输出N的阶乘
```
var n = parseInt(window.prompt('N=?'));
function factorial(n) {
  // 错误机制
  if(n <= 0) {
  	return '输入有误';
  }
	// 递归出口
  if(n === 1) {
  	return 1;
  }
  return n * factorial(n - 1);
}
var num = factorial(n);
console.log(num);

// 执行过程形成的队列
factorial(5) = factorial(4) * 5;
factorial(4) = factorial(3) * 4;
factorial(3) = factorial(2) * 3;
factorial(2) = factorial(1) * 2;
factorial(1) = 1;
```

# 预编译
## js引擎解析代码的执行顺序
1. 检查通篇的代码错误，如果有则直接抛出语法错误(任何代码不执行)， 没有进行预编译
2. 进行预编译
3. 解释一行，执行一行

暗示全局变量（imply global variable）
ES3 没有用var声明的变量会被挂载到 全局对象上

## 函数中的预编译步骤 AO(activation object)函数执行期上下文
1. 寻找函数的形参和变量声明
2. 实参赋值给形参
3. 寻找函数声明
4. 执行函数
```
function test(a, b) {
	console.log(a); // 1
  c = 0;
  var c;
  a = 5;
  b = 6;
  console.log(b); // 6
  function b(){};
  function d(){};
  console.log(b); // 6
}
test(1);

// 预编译
// AO = {
	 a:undefined,
     ---> 1
		 ---> 5
   b:undefined,
     ---> function b(){}
		 ---> 6
   c:undefined,
     ---> 0
   d:function d(){}
}
```

## GO(global object)全局对象，全局执行期上下文 预编译步骤
1. 寻找变量声明
2. 寻找函数声明
3. 执行代码
```
console.log(a, b); // function a(){}  undefined
function a(){};
var b = function(){};

// 预编译
GO = {
	b:undefind,
  --> function(){}
  a:function a(){},
}
```

## 关于AO与GO的一些疑惑点
1. 函数声明在预编译期间进行声明提升，为什么函数表达式不会呢？
因为在GO的预编译期间，首先寻找变量声明，var fn就是变量声明，而var fn = function(){}；虽然是函数声明的一种方式，但是它的执行顺序是，先创建一个变量fn，然后通过赋值的方式将function fn(){}函数在栈内存中的地址赋值给变量fn；所以function(){}函数是在JS引擎执行脚本语言代码的时候定义的。所以在预编译第二阶段寻找函数声明的时候找不到这个匿名函数。这个匿名函数是在JS引擎执行脚本语言是被定义的，GO是对象不会执行。
```
console.log(fn); // undefined
var fn = function(){};
```

2. 预编译的存在的意义
GO和AO的定义是让JS引擎看的，预编译是为了让JS引擎能够更好的去解析代码。上面的例子，在JS引擎执行脚本语言的时候，才将{}赋值给obj变量，obj变量内部存放是的指向{}的指针，obj的name属性存放着指向function(){}的指针，当这个对象被定义的时候，匿名函数才会被定义。反过来说，如果单纯的提升一个匿名函数，这个匿名函数也没有指向，对于代码整体来说没有任何意义。预编译去寻找变量的目的是：这次执行先要确定有哪些变量，然后才好去赋值。

## 代码

1. 因为AO环境中预解析时有a变量，所以就不去GO找了
```
a = 1;
function test() {
  // 因为AO环境中预解析时有a变量,所以就不去GO找了
	console.log(a); // undefined
  a = 2;
  console.log(a); // 2
  var a = 3;
  console.log(a); // 3
}
test();
var a;

// GO = {
		a:undefined,
      --> 1
  	test:function() {},
}

// 因为AO环境中预解析时有a变量,所以就不去GO找了
// AO = {
		a:undefined,
    --> 2
    --> 3
}
```

2. 预编译不看语句判断，只看有没有变量声明和函数声明
```
function test() {
	console.log(b); // undefined
  if(a) {
  	var b = 2;
  }
  c = 3;
  console.log(c); // 3
}
var a;
test();
a = 1;
console.log(a); // 1

// GO = {
	 a:undefined,
     --> 1
   test:function test(){},
   c:undefined,
     --> 3
}

// AO = {
	 b:undefined,
   	--> 2
}

```

```
var b = 1;
function test() {
	var a = 1;
  var b = 2;
  console.log(b); // 2
}
test();

// 预解析
GO = {
	b: undefined,
  --> 1
  test:function test(){},
 
}

AO = {
	a:undefined,
  --> 1,
  b:undefined,
  --> 2,
}
```

```
var b = 3;
console.log(a); // function a(a) {}
function a(a) {
	console.log(a); // function a() {}
  var a = 2;
  console.log(a); // 2
  function a() {};
 	var b = 5;
  console.log(b); // 5
}
a(1);

// GO = {
	 b:undefined,
     --> 3,
   a:function a(a) {}
}

// AO = {
	 a:undefined,
     --> 1
     --> function a(){}
     --> 2
   b:undefined,
     --> 5
}
```