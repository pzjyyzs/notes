为什么需要了解AO和GO呢？因为要利用AO和GO解决作用域，作用域链相关所产生的一切问题；

# 函数也是一种对象的类型，也是引用类型，引用值
函数也拥有属性，所以也是对象的一种形式；fn.name，fn.length，fn.prototype等，静态属性；

# 函数的隐式属性(无法访问，JS引擎内部固有的隐式属性)
## [[scope]] (作用域)属性，[scope Chain](作用域链)属性

1. 函数创建时，生成的一个JS内部的隐式属性[[scope]];
2. [[scope]]属性是函数存储作用域链的容器;
3. [scope Chain]作用域链是存储函数的AO/GO的容器;
4. AO：函数执行期上下文    GO：全局的执行期上下文，AO是一个即时的存储容器
5. 函数执行完成之后，AO是要销毁的，函数重新执行，会重新生成一个新的AO，老的AO会被销毁；
6. 函数不调用就不会执行，如果不执行，那么内部的其他函数声明也不会被定义；

作用域链：把AO与GO从上往下排列起来，将这些GO和AO形成链式的关系，就叫做作用域链；

预编译
```
function a() {
	function b() {
  	var b = 2;
  }
	var a = 1;
  b();
}
var c = 3;
a();

// 预编译 AO,GO
GO = {
	c:undefined,
  -->3,
  a:function a(){};
}

// a函数的AO
AO = {
	a:undefined,
  --> 1
  b:function b() {}
}

// b函数的AO 
AO = {
	b:undefined;
  --> 2
}
```

每一个函数的作用域链里面都是包含GO的，每一个函数被定义的时候，它就已经包含全局执行期上下文GO

- 在a函数被定义时，系统自动生成[[scope]]属性，[[scope]]属性保存着该函数的作用域链[Scope Chain]， 该作用域链的第0位储存着当前环境下的全局执行期上下文GO，GO里存储全局下的所有对象，其中包括函数a和变量c。
- 当函数a被执行时(前一刻)，作用域链的顶端存储a函数生成的函数执行期上下文AO,同时第一位存储GO.查找变量从顶端开始依次向下。
- 当b函数被定义时，是在函数环境下，所以b函数这时的作用域链就是a函数执行期的作用域链。
- 当b函数被执行时(前一刻),生成函数b的[[scope]],存储函数b的作用域链，顶端0位存储b函数的AO,a的AO和GO依次向下排列。
- 当b函数被执行结束后，b函数AO被销毁，回归被定义的状态。
- 当a函数被执行结束后，a函数的AO被销毁的同时，b函数的[[scope]]也将不存在。a函数回归被定义时的状态。
函数被定义有[[scope]],执行前，生成AO。

闭包
当内部函数被返回到外部保存时，一定会产生闭包，闭包会产生原来的作用域链不释放，过渡的闭包可能会导致内存泄漏或加载过慢