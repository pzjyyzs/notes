# 构造函数中的this和this的原理
## 在函数中 this是否存在，它指代是什么
1. 
```
function Car() {
    this.color = '蓝色';
}
```
this是AO函数执行期上下文中的一个属性，并且this指向的是对象;Car()函数虽然此时因为被声明，产生作用域与作用域链；但是Car()函数并没有执行，没有产生Car()函数的执行期上下文，所以此时并不存在this；也不存在this指向的问题；

2. 
```
function Car(){
	this.color = '蓝色';
}
Car();
```
Car()函数执行，在Car()函数执行的前一刻产生函数的AO函数执行期上下文，此时由于Car()函数是独立调用的，所以函数内部的this指向window，此时this.color = '蓝色'，相当于window.color = '蓝色'；

## 通过new关键字实例化构造函数，构造函数内部的this指向是什么
通过new关键字对构造函数进行调用，此时构造函数内部的this由window改为当前的实例化对象，也就是说new关键字改变了构造函数内部的this指向；
```
function Car(opt) {
	this.color = opt.color;
  this.brand = opt.brand;
}

var c1 = new Car({
	color:'蓝色',
  brand:'benz'
});

console.log(c1); // { color:'蓝色', brand:'benz' };
console.log(window.color, window.brand); // undefined undefined
```

## 构造函数实例化出来的对象是同一个对象吗？二者互相影响吗？
1. 在函数没有被new关键字调用时，函数内部的this指向默认指向为window对象（非严格模式下）；
2. 函数成为构造函数通过关键字new，new关键字改变构造函数中的this指向，将this指向window对象改为指向实例化对象；
3. 通过构造函数实例化出来的对象，由于在实例化构造函数时内部的this指向不同，所以实例化出来的对象也互不影响；
```
function Car(opt) {
	this.color = opt.color;
  this.brand = opt.brand;
}
var c1 = new Car({
	color:'蓝色',
  brand:'benz'
})

var c2 = new Car({
	color:'绿色',
  brand:'BMW'
})
c1.color = '黄色';

console.log(c1); // { color : '黄色', brand : 'benz'};
console.log(c2); // { color : '绿色', brand :  'BMW'};
```

## 构造函数中this的原理，以及new关键字对构造函数的作用?
1. new关键字对构造函数的作用
- 不通过new关键字实例化函数
如果不通过new关键字对函数进行调用，则函数独立调用，此时函数内部的this在函数执行的前一刻产生，并且默认指向window对象，并且函数调用完成之后内部默认隐式返回undefined；
```
function Car(color, brand) {
  // this ---> window
  this.color = color;
  this.brand = brand;
  // 隐式 return undefined
}
// 独立调用
var c1 = Car('蓝色', 'benz');
console.log(c1); // undefined
```

- 通过new关键字实例构造函数
通过new关键字对构造函数进行调用，此时构造函数的内部因为new关键字的原因，在构造函数执行前一刻时隐式创建一个this = {} 的对象，并且将构造函数内部的this指向从window指向为新创建的this对象，当构造函数调用时，构造函数内部为这个新的this对象进行相应的属性赋值，并且在构造函数的最后，new关键字隐式的将这个新创建的this对象返回出去（return this）；
new关键字与构造函数实例化对象的步骤：
1. new关键字在构造函数中隐式创建新的this对象，将函数内部的this对象指向从window改为新的this对象；
2. 构造函数调用执行，初始化this对象的属性和方法，并且进行赋值；
3. new关键字在构造函数中隐式返回新创建的this对象；

```
function Car(color, brand) {
  // 隐式创建
  // this = {}
  
  // 赋值
  this.color = color;
  this.brand = brand;
  
  // 隐式
  return this;
}

var c1 = new Car('蓝色', 'benz');
console.log(c1); // {color:'蓝色', brand:'benz'}
```

## 模拟new关键字在构造函数中的操作
```
function Car(color, brand) {
  var me = {};
	me.color = color;
  me.brand = brand;
  return me;
}
var c1 = Car('蓝色', 'benz');
console.log(c1); // { color:'蓝色', brand:'benz' };
```

## 构造函数的返回值的注意事项
返回原始类型 显式让构造函数返回原始值类型数据，此时构造函数的返回值不受影响，依旧返回this对象。
```
function Car(color, brand) {
	this.color = color;
  this.brand = brand;
  return '111'; 
  // return 'str';
}
var c1 = new Car('蓝色', 'benz');
console.log(c1); // { color:'蓝色', brand:'benz' };
```
返回引用类型 显式让构造函数返回引用类型的值，此时构造函数的返回值就是引用类型的值。
```
function Car(color, brand) {
	this.color = color;
  this.brand = brand;
  return {};
  // return [];
  // return function(){};
}
var c1 = new Car('蓝色', 'benz');
console.log(c1); // {} [] function(){}
```

# 包装类
原始值类型的数据是不存在属性和方法的，所以尝试给原始值数据类型设置属性都失败了，最终获取原始值数据的属性结果是undefined；
```
var a = 1;
a.len = 3;
console.log(a.len); // undefined

var str = 'abc';
str.add = 'bcd';
console.log(str.add); // undefined

var fn = true;
fn.add = function(){};
console.log(fn); // undefined
```
但是字符串类型打印length为什么会有结果呢 这是JS中的包装类做出的贡献；
```
var str = 'abc';
console.log(str.length); // 3
```

JS中存在的三大包装类
new String() new Number() new Boolean();
当我们创建一个基础类型的时候，js会给我们创建一个一个对应类型的包装类，比如var a = '123'; -> var a = new String('123');
调用实例上对应的方法
最后就是销毁实例。
这个会销毁的特性导致我们不能为基础类型添加属性和方法
```
const word = 'you are the best'
word.name= 'john'
console.log(word.name) //undefined
```
执行到第二行代码属性赋值时，后台创建了一个基本包装类型的实例，这个属性确实挂到实例上了，紧接着就被销毁了，第三行又重新创建了新的基本包装类型的实例，就没有属性了。