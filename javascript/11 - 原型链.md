原型链其实就是沿着对象的[[prototype]]或者_proto_属性去找prototype里的属性，一层一层的去继承里prototype的属性，形成的这条链条就叫做原型链；
例如我们有一个Person的构造函数
```
function Person(age){
    this.age = age
}
var p = new Person(12);
```
p._proto_  -> Person.prototype
Person.prototype._proto_ -> Object.prototype
Person._proto_ -> Function.prototype
Function.prototype -> Object.prototype
Object.prototype._proto_ = null;

原型链的终点是Object.prototype._proto_ = null

# 原型链的继承
根据原型链的特性可以实现继承
```
// Professor构造函数
function Professor() { 
  this.HSkill = 'Vue'
};
Professor.prototype.sideHustle = 'Java';

// Teacher实现继承Professor
Teacher.prototype = new Professor();

// Teacher构造函数
function Teacher() {
  this.mSkill = 'JS/JQ';
}

// Student实现继承Teacher
Student.prototype = new Teacher();

// Student构造函数
function Student() {
  this.pSkill = 'HTML/CSS';
}
```
Student继承了Teacher， Teacher继承了Professor,Student可以获得sideHustle。能实现的关键点```Student.prototype = new Teacher();Teacher.prototype = new Professor();```
把Teacher实例化对象的引用赋值给了Student.prototype,从而修改了Student.prototype原本在内存中保存的旧引用。
实例化本身存在_proto_属性，new Student()实例化对象在没有进行Student.prototype = new Teacher();操作的时候，内部的_proto_属性保存的是Student.prototype。
```
new Student() = {
  __proto__ : new Teacher() = {
    __proto__ : new Professor() = {
      __proto__ : Professor.prototype = {
        __proto__ : Object.prototype = {
          __proto__ : null
        }
      }
    }
  }
}
```

实例对象是否能修改原型属性
子类无法修改夫类的属性。如果修改属性，会给自己增加一个新的属性