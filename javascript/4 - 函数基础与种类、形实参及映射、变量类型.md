# 函数的作用
1. 固定的功能或者程序段被封装的过程。需要一个入口和出口，入口就是参数，出口就是返回值。
2. 解耦合。 耦合：代码的重复度高。函数能够让一个独立功能的代码封装起来，需要这个功能的程序调用就可以。

# 声明和命名规范

## 命名规范
1. 不能以数字开头， 可以包含数字
2. 可以字母_$符号开头
3. 小驼峰
4. 区别大小写

## 声明方式

1. 函数声明
```
function 函数名 (参数) {
    // 函数体 
}
```

2. 函数字面量/函数表达式
```
var 函数名 = function (参数) {
    // 函数体
}
```

函数拥有属性和方法， 函数名. 的方式使用和调用。例如函数名.length 可以打印形参的个数。形参的数量不包括剩余参数的个数，仅包括第一个具有默认值之前的参数个数。与之对比的是，arguments.length是函数被调用时实际传参的个数。

# 函数参数
## 形参
形式上的占位符，在函数体内的变量
```
function test (a, b){

}
```

## 实参
实际参数就是给形参赋值用的
```
function res(a, b) {
  console.log(a + b);
}
res(1, 2); // 1 2就是实际参数
```

## 注意事项
1. 实际参数在给形式参数赋值的时候，参数传递是一一对应的规则
2. 函数参数传递的时候，不在乎数据的类型，实际参数没有数据类型的规范，任何数据都可以传递
3. 函数传递参数的时候，形参和实参的个数可以不相等，未接收到实际参数赋值的形式参数，值为undefined。
4. 函数内部可以使用arguments(类数组对象), 获取实际参数
5. 内部获取实参和形参长度
```
function res(a, b) {
		console.log(arguments.length); // 实参 3
  	console.log(arguments.callee.length); // 形参 2
  	console.log(res.length); // 形参 
}
res(1, 2, 3);
```
6. 映射关系
- 函数内部是可以更改实际参数的值，例如用户填的数不合法，我们可以更改用户传递的值；
```
function res(a, b) {
  	a = 3;
  	console.log(a); // 3
  	console.log(arguments[0]); // 3
}
res(1, 2);
```

- *实际参数数量 < 形式参数的数量*，由于实际参数的数量 < 形式参数的数量，其中形式参数b并没有实际参数与之传递参数，在函数体内部，形式参数b被赋值为3，按照之前的定义实际参数arguments[1]应该与b随之发生改变，但是实际上由于形式参数b并没有实际参数与之对应，导致在函数体内部丢失掉实际参数与形式参数的映射关系，所以arguments[1]不会发生变化，依旧是undefined；
```
function res(a, b) {
	b = 3;
	cosole.log(b); // 3
	console.log(arguments[1]); // undefined
}
res(1);
```
- 函数体内部，形式参数a和arguments[0]实际参数是同一个参数吗？
虽然二者输出的结果相同，但是二者并不是同一个变量。因为在形式参数a是储存在栈内存中，arguments[0]是储存在堆内存中的，但是在函数体内部，系统自动将形式参数与实际参数建立起映射的关系，如果实际参数与形式参数数量相同的情况下，无论实际参数的值怎么变化，形式参数都会随之改变；

7. 实际参数和形式参数在函数执行的时候进行赋值操作，此时函数内部实际参数与形式参数形成映射关系，当形式参数在函数内部作用域改变时，为什么传递的实际参数在函数外部不随着形式参数改变而改变呢?
实际参数和形式参数在函数内部才具有映射关系，函数中的arguments中储存着实际参数的值，虽然在函数内部能够通过arguments进行改变实际参数的值影响形式参数的值，但是arguments和实际参数并不是同一个东西;（实际参数与形式参数的映射关系只存在于函数内部作用域中，在函数外部作用域中并不具有映射关系。）
```
// 原始值
var a = 1;
function test(a) {
	a = 3;
	console.log(a); // 3
	console.log(arguments[0]); // 3
}
test(a);
console.log(a); // 1


// 引用值
var a = {
	name: 'tom'
}
function test(a, b) {
	a = new Object({ name: 'Shelly' });  // 改变形式参数的引用
	console.log(a); // shelly
	console.log(arguments[0]); // 实际参数随着改变 shelly
}
test(a);
console.log(a); // 没改变 tom
```

下面例子其实看似是映射关系能存在函数外部作用域中，其实不然。实际参数与形式参数赋值时，将a对象的引用赋值给形式参数，函数内部只是修改了a对象引用中的一个属性。所以外界打印对象a中name属性随之改变，但不属于映射关系，只是修改引用中的属性罢了。
```
var a = {
	name: 'tom'
}
function test(a,b) {
	a.name = 'Jack';
	
	console.log(a); // jack
	console.log(arguments[0]); // jack
}
test(a);
console.log(a); // jack
```
# 函数的返回值

1. 如果没有return 会默认返回 undefined
2. 遇到return 后 函数停止运行，后面的代码不会执行。
3. 在return关键字被返回的表达式之间不允许使用行终止符,会默认返回undefined

# 函数内局部变量
ES3 在函数内使用var声明的变量，无法在函数外部使用
```
function test() {
  var a = 2; // 局部变量
}
test()
console.log(a); // Uncaught ReferenceError: a is not defined;原因和作用域有关,之后章节介绍
```
如果不使用var 来声明并直接给变量赋值的。会被挂载到全局作用域
```
 // 全局变量
function test() {
    b = 1;
}
test();
console.log(b); // 1
```