原型prototype本质是构造函数的属性，并且是构造函数的prototype属性在栈内存中保存一个对象引用。
构造函数如果不通过new关键字实例化对象的话，本质上与普通函数并没有什么区别。原型既然是对象的话，那么这个对象中存在constructor属性，这个constructor属性在栈内存中保存的构造函数的引用。
实例对象，通过关键字new在构造函数中隐式创建一个this对象，而在构造函数执行完成之后，隐式的将this返回出去。而this对象中存在_proto_属性，这个_proto_属性中保存构造函数prototype属性，也就是说_proto_属性与构造函数的prototype属性指向prototype对象保存的引用。
一切由构造函数实例化出来的对象都是继承于原型对象的。

# 原型链继承
```
/**
* 教授构造函数 
*/
function Professor() {
}
/**
* 重写教授原型属性
* 
*/
Professor.prototype = {
  name: 'Mr.zhang',
  tSkill: 'Java'
}
/**
* 实例化教授实例对象
*/
var profess = new Professor();

/**
* 教师构造函数
*  
**/
function Teacher() {
  this.name = 'Mr.zhang',
  this.mSkill = 'JS/JQ';
}
var teacher = new Teacher();
console.log(teacher.tSkill); // undefined
Teacher.prototype = new Professor();
```
首先profess教授的实例对象中__proto__属性存放的是Professor构造函数的prototype属性，所以我们只需要让teacher能够继承profess实例对象的话，那么间接的就可以访问到Professor.prototype。整个过程teacher--> professor --> Professor prototype。
我们的继承过程是teacher -> new Professor() -> Professor.prototype。这样一来，是不是new Professor()实例对象上的属性teacher都能够继承到，其实我们需要的子类并不是要继承到父类上所有的方法。

# 圣杯模式继承，企业级继承
之前我们说原型链继承的过程是teacher ->  new Professor() -> Professor.prototype，但是我们想简化成teacher -> Professor.prototype，因为我们不想继承new Professor()实例对象上的属性，因为实例对象上的属性实例化时可能都会变化，所以不适合我们继承。
既然我们不想要继承到new Professor()实例对象上的属性，那么我们可不可以给它换成一个空对象，我们在子类和父类继承之间增加一个缓冲层，如果现在是这样一个继承过程：teacher --> new Buffer() --> Professor.prototype，这样是不是既可以实现继承，又可以实现我们不想继承到new Professor()上属性的需求呢？
```
function Professor() {
  this.name = 'Mr.zhang';
  this.mSkill = 'JS/JQ';
}
Professor.prototype = {
  students: 300
}

function Teacher() {
  this.name = 'Mr.wang'
}

// 创建缓存层
function Buffer() {}
// 重写Bufffer.prototype
Buffer.prototype = Professor.prototype;
// 重写Teacher.prototype
Teacher.prototype = new Buffer();

var t1 = new Teacher();
console.log(t1);


// 此时原型链形式
new Teacher() {
  name:'Mr.wang'
  __proto__: new Buffer() {
    __proto__: Professor.prototype: {
      students: 300
      __proto__: Object.prototype
    }
  }
}
```

函数封装
```
function Teacher() { }
function Student() { }

/**
	* @params {* Target: 目标对象}
  * @params {* Origin: 源始对象}
  * 
  */
function inherit(Target, Origin) {
	var Buffer = function(){}
	Buffer.prototype = Origin.prototype;
	Target.prototype = new Buffer();
	// 设置目标原型的constructor
	Target.prototype.constructor = Target;
	// 设置继承的父类
	Target.prototype.super_class = Origin;
}

// 实现圣杯继承
inherit(Student, Teacher);
```
闭包封装
```
function test() {
	var Buffer = function() {};
  function inherit(Target, Origin){
  		Buffer.prototype = Origin.prototype;
    	Target.prototype = new Buffer();
    	Target.prototype.constructor = Target;
    	Target.prototype.super_class = Origin;
  }
  return inherit;
}

// 模块化封装圣杯继承
var inherit = (function(){
	var Buffer = function(){};
  return function(Target, Origin){
  	Buffer.prototype = Origin.prototype;
    Target.prototype = new Buffer();
    Target.prototype.constructor = Target;
    Target.prototype.super_class = Origin;
  };
})();

inherit(Student, Teacher);
```