# 原型
prototype，一个对象。几乎所有的对象在创建时，都会赋予一个非空的值。有空的。
## 解决了什么问题
- 如果在对象本身无法找到需要的属性，就会访问对象的原型，一直到顶端
- 实例对象的共有属性和方法可以放在原型中，相同的部分被放在一起，这样解决了代码庸余和高耦合的问题。
## 原型和实例对象有什么联系
1. protoype（原型）是构造函数的属性，只不过prototype属性是个对象而已。构造函数.prototype能够访问到原型，prototype（原型）是构造函数构造出来的每个实例对象的公共祖先；
2. 所有被该构造函数构造出来的对象都可以继承原型上的属性和方法；
3. 当实例对象未拥有的属性或者方法才会去原型上寻找，如果自身存在该属性，那么就使用自身的属性或者方法；

```
function Handphone(brand, color) {
	this.brand = brand;
  this.color = color;
  this.say = function(){
  	console.log('I say hello!');
  }
}
var h1 = new Handphone('Benz', 'blue'); 
var h2 = new Handphone('BMW', 'red');

// 我们能够发现通过构造函数的prototype属性能够访问到原型,而且原型还是对象的形式。
console.log(Handphone.prototype); // { constructor: Handphone(brand, color){} }

// 原型上设置实例对象公有的属性和方法
Handphone.prototype.rom = '64G';
Handphone.prototype.ram = '8G';
Handphone.prototype.screen = '18:9';
Handphone.prototype.system = 'Android';
Handphone.prototype.call = function() {
		console.log('I am calling somebody');
}

// 实例对象继承原型的属性或者方法
console.log(h1.rom); // '64G'
console.log(h2.ram); // '8G'
console.log(h1.call === h2.call); // true
```

# constructor
constructor属性是属于prototype, 指向构造函数本身，因为constructor只是prototype对象上的一个属性，constructor在栈内存中保存着构造函数的引用，所以可以通过修改引用，而更改constructor的指向；
```
function HandPhone(brand, color) {
  this.brand = brand;
  this.color = color;
}
console.log(HandPhone.prototype);
console.log(HandPhone.prototype.constructor);
```


# 构造函数，prototype，__proto__的关系
在新版的Chorme浏览器中将__proto__属性以[[prototype]]属性显示

## 构造函数
1. 通过new关键字对构造函数进行实例化，new关键字在构造函数中隐式创建一个this空对象，改变当前构造函数内部的this指向；
2. 初始化实例对象的属性和方法，并且指定原型（下面详细介绍）；
3. 构造函数执行完成，将新创建的this对象返回到全局中；
4. 将实例化后的this对象赋值给全局变量进行保存，此时实例化对象就已经完成实例化；

## prototype
1. 在构造函数实例化的时候，new关键字在构造函数内部创建新的this对象，在this对象中存在隐式属性__proto__，而隐式属性__proto__保存的是构造函数的prototype属性（function.prototype）;
2. 实例化对象通过自身去寻找不存在的属性，就会沿着隐式属性__proto__：function.prototype去寻找自身不存在的属性，而__proto__保存的是function.prototype，所以实例对象就会去function.prototype（原型对象）上寻找属性；


## __proto__属性的特点
1. __proto__属性是实例化对象以后的结果，__proto__属于实例对象的隐式属性，如果不通过new对构造函数进行实例化，那么就不存在新创建的实例对象this，那么实例对象的__proto__属性也就不存在，也就是说__proto__是实例化之后的结果；
2. __proto__隐式属性是每一个实例化对象存放原型的容器：__proto__：function.protoype
3. 实例对象中存在__proto__属性，其中保存着构造函数的prototype属性，所以function.prototype（原型）是属于实例化对象的，不是属于构造函数的；
4. 每一个实例对象都有__proto__属性，保存着其构造函数的prototype属性；