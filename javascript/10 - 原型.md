# 原型
prototype，一个对象。几乎所有的对象在创建时，都会赋予一个非空的值。有空的。
## 解决了什么问题
- 如果在对象本身无法找到需要的属性，就会访问对象的原型，一直到顶端
- 实例对象的共有属性和方法可以放在原型中，相同的部分被放在一起，这样解决了代码庸余和高耦合的问题。
## 原型和实例对象有什么联系
1. protoype（原型）是构造函数的属性，只不过prototype属性是个对象而已。构造函数.prototype能够访问到原型，prototype（原型）是构造函数构造出来的每个实例对象的公共祖先；
2. 所有被该构造函数构造出来的对象都可以继承原型上的属性和方法；
3. 当实例对象未拥有的属性或者方法才会去原型上寻找，如果自身存在该属性，那么就使用自身的属性或者方法；

```
function Handphone(brand, color) {
	this.brand = brand;
  this.color = color;
  this.say = function(){
  	console.log('I say hello!');
  }
}
var h1 = new Handphone('Benz', 'blue'); 
var h2 = new Handphone('BMW', 'red');

// 我们能够发现通过构造函数的prototype属性能够访问到原型,而且原型还是对象的形式。
console.log(Handphone.prototype); // { constructor: Handphone(brand, color){} }

// 原型上设置实例对象公有的属性和方法
Handphone.prototype.rom = '64G';
Handphone.prototype.ram = '8G';
Handphone.prototype.screen = '18:9';
Handphone.prototype.system = 'Android';
Handphone.prototype.call = function() {
		console.log('I am calling somebody');
}

// 实例对象继承原型的属性或者方法
console.log(h1.rom); // '64G'
console.log(h2.ram); // '8G'
console.log(h1.call === h2.call); // true
```

# constructor
constructor属性是属于prototype, 指向构造函数本身，因为constructor只是prototype对象上的一个属性，constructor在栈内存中保存着构造函数的引用，所以可以通过修改引用，而更改constructor的指向；
```
function HandPhone(brand, color) {
  this.brand = brand;
  this.color = color;
}
console.log(HandPhone.prototype);
console.log(HandPhone.prototype.constructor);
```


# 构造函数，prototype，实例对象的关系
在新版的Chorme浏览器中将__proto__属性以[[prototype]]属性显示
就是每一个对象都有一个隐式的内部属性[[prototype]]，除了通过Object.create(null)方式创建的孤儿对象；
在使用new在构造函数调用的时候，函数内部创建了一个隐式的this对象，在构造函数调用结束后返回这个创建的this对象。

构造函数的prototype,它是一个对象，打印prototyp的constructor,可以找到构造函数。可以通过fn.prototype.constructor找到fn.
每一个实例的_proto_属性指向的对象 和prototype是一样的。
我们在new调用构造函数的时候，会创建一个隐式的this对象，之前说过每个对象都存在[[prototype]]，当前this这个对象也不例外，此时这个对象中的属性存放的就是prototype属性。在构造函数调用完成时返回了这个this对象，所以当我们访问_proto_属性的时候，其实就是顺着_proto_属性去访问prototype属性在栈内存中存放的引用；