# 对象
对象是一组没有特定顺序的值。对象的每个属性或者方法都有一个名字，而每个名字都映射到一个值；
对象字面量的创建
var obj = {}

系统自带构造函数创建对象
var obj = new Object();
```
var teacher = {
	// 属性
  name : '张三',
  age : 32,
  sex : 'male',
  height : 176,
  weight : 130,
	// 方法
  teach : function() {
    this.age++;
    console.log(' I am teaching JavaScript');
  },
  smoke : function() {
  	console.log(' I am smoking');
  },
  eat : function() {
  	console.log(' I am having a dinner');
  }
}
```
调用值
teaccher.name 或 teacher['name'];

增加属性值 或 修改属性值
teacher.address = "广州"; // 增加一个没有的属性
teacher.age = 12; // 修改一个已知的属性

删除一个属性
delete teacher.address

对象中的this
teacher的teach方法中使用了this属性，当teacher调用了这个方法后，this就隐式绑定了调用了这个方法的teacher对象

# 构造函数

使用new 来调用的函数，成为构造函数。构造函数主要功能是初始化对象，特点是和new一起使用。一般首字母大写。
初始化的时候，this是不存在的，没有执行的时候，thi的指向是不知道的。只有实例化过对象后,this是实例化对象
new出来的对象是相互不影响的。
```
function Teacher() {
    this.name = 'test';
    this.age = 12;
}
var a = new Teacher();
```

传递参数 没有传递就是undefined
```
function Car(brand, color) {
	this.brand = brand;
  this.color = color;
}
var car = new Car('benz', 'yellow');

function Teacher(opt) {
	this.name = opt.name;
  this.sex = opt.sex;
  this.age = opt.age;
  this.weight = opt.weight;
  this.smoke = function() {
  	this.weight--;
    console.log(this.weight);
  };
  this.eat = function() {
  	this.weight++;
    console.log(this.weight);
  }
}

// 创建实例
var t1 = new Teacher({
	name:'张三',
  age:18,
  sex:'男士',
  weight:120
});
```

# 链式调用
```
var sched = {
	wakeup: function() {
		console.log('Running')
		return this;
	},
	noon: function() {
		console.log('Havaing a rest');
		return this;
	},
	night: function() {
  	console.log('Sleeping');
		return this;
  }
}
```
# [] 语法 可以接受特殊符号的对象属性；可以接受变量
点语法 是 隐式处理成 []语法的
为什么obj[name]，当前没有name变量，程序不会抛出错误呢？
1. 全局作用域下，console.log(name === window.name) // true，也就是说在全局作用域中定义的变量和方法都将映射到window对象上，所以直接打印console.log(name)并不会报错，但是必须是window对象上拥有该属性。
2. obj[name]中，现在name是变量，所以JS引擎会去找变量name（是在作用域中寻找）。此时所处的作用域是全局作用域（global），在全局作用域global的确存在name变量，并且值是''字符串，所以obj['']---》undefined。
3. obj[age]抛出错误的原因是，现在全局作用域中window对象中并不存在age变量，所以现在会抛出程序异常。

# 对象属性枚举
```
var arr = [1, 2, 3];
for(var i = 0; i < arr.length; i++) {
		console.log(i); // 1 2 3
}
```
for in 枚举
```
var car = {
	brand : 'Benz',
  color : 'red',
  displacement:'3.0',
  lang:'3',
  width:'2.5'
}

// for in 遍历对象
只遍历自身对象的属性，不遍历原型链上的
for(var key in car) {
	console.log(key + ':' + car.key); // 为什么car.key输出的undefined呢?
  console.log(key + ':' + car[key]); // []语法
}
```

# hasOwnProperty/in
Object.prototype.hasOwnProperty() 返回一个布尔值，该方法用来检测属性是否属于对象自身。
```
var obj = {
	name : '张三',
  age : 32,
  sex : '男'
}

console.log(obj.hasOwnProperty(obj.name)); // false
console.log(obj.hasOwnProperty('name')); // true
console.log(obj.hasOwnProperty('age')); // true
console.log(obj.hasOwnProperty(obj.hobby)); // false
```

in 如果属性在指定对象或其原型链中，返回true
```
var trees = new Array("redwood", "bay", "cedar", "oak", "maple");
0 in trees        // 返回 true
3 in trees        // 返回 true
6 in trees        // 返回 false
"bay" in trees    // 返回 false (必须使用索引号，而不是数组元素的值)
```
# instanceof 运算符
用于检测构造函数的prototyp属性是否出现在某个实例对象的原型链上。判断基础类型都会返回false
```
function C() {};
function D() {};
var o = new C();

o instanceof C; // true
o instanceof Object; // true
o instanceof D; // false
```
