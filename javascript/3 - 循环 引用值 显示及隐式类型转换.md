# 循环
## for
格式声明
```
for(声明变量; 条件判断(返回true或false) ; 变量增长) {
    // do Something
}
for(var i = 0; i < 10; i++) {
  	console.log('to do something');
}
```
步骤
1. 声明变量i并赋值
2. 根据条件判断返回相应的boolean值
3. 增加变量i的值

### for循环中的判断条件

1. 死循环的问题

由于声明变量i不能等于0，因为作为for循环的判断条件，此时存在隐式类型转换，这样不满足for循环的判断条件，就进入不到for循环的代码块中；

```
var i = 0;
for(;i;) { 
  console.log(i);
  i++;
}
```
死循环的生成，声明i变量等于1，此时for循环的判断条件，在进行判断时对变量i进行隐式转换，Boolean(i) --> true；判断条件i一直处于满足true的情况（i == 1, i==2, i==3），导致判断条件一直成立，程序停止不了，造成死循环的问题；

```
var i = 1;
for(;i;) {
  console.log(i);
  i++;
}
```

2. 解决 
- break 和 continue 处理死循环的问题
- 利用 变量不满足for循环判断的条件处理

**do-while 和 while 省略 可以看mdn**

# 初识Array和Object

## Array
```
var arr = [1, 2, 3, 4, 5];
console.log(arr[1]);

// 数组修改值
arr[1] = '我是修改之后的值';
arr[0] = null;  // [null, 2, 3, 4, 5]

// 默认属性length
console.log(arr.length);
```

## Object

```
// 对象字面量声明
var obj = {
	'属性名/键名':'属性值/键值',
  name:'小张',
  age:18
}

// 对象取值
console.log(obj.name);

// 对象赋值
obj.name = '小王';
```

# typeof 判断类型
typeof()方法是JavaScript内置的方法，返回值是数据类型；typeof()方法返回值是判断后的数据类型，但是是**字符串**形式返回的。

返回值 'number' 'string' 'boolean' 'undefined' 'function' 'object'

null 的typeof 是object 因为null指代的是空对象的指针和空对象的占位符

未被定义的变量返回 字符串 undefined
```
typeof(a)
```

基本使用
```
typeof(123); // number 
typeof('123'); // string
typeof(true); // boolean
typeof(null); // object
typeof(undefined); // undefined
typeof(function(){}); // function
typeof({}); // object
typeof(NaN); // number
```

# 显示类型 和 隐式类型转换

## 显示类型转换

1. Number
直接将参数转化为数字类型，如果不能转化则返回NaN；
```
typeof(Number('.123')); // 0.123 number
typeof(Number(' .123')); // 0.123 number
typeof(Number(123)); // 123 number
typeof(Number('123')); // 123 number
typeof(Number(true)); // 1 number
typeof(Number('true')); // NaN number
typeof(Number(null)); // 0 number
typeof(Number(undefined)); // NaN number
typeof(Number('1a')); // NaN number
typeof(Number('3.14')); // 3.14 number
typeof(Number('')); // 0 number
typeof(Number(' ')); // 0 number
typeof(Number(-1)); // -1 number
```

2. String类型和toString()方法
String类型显式转换
```
// String将数据直接转化为字符串类型
String(123); // 123 string
String('123'); // 123 string
String(NaN); // NaN string
String(null); // null string
String(true); // true string
```

toString() 方法返回指定对象的字符串形式
**null和undefined没有toString()方法，具体原因到包装类就会知道**

3. Boolean类型
Boolean判断为false的值： undefined null NaN 0 false ''(空字符串)
```
Boolean(undefined); // false
Boolean(null); // false
Boolean(false); // false
Boolean(''); // false
Boolean(' '); // true -->有空格
Boolean(NaN); // false
Boolean(0); // false
```

## 隐式类型转换
1. Number隐式类型转换 针对基础类型

+ - * / %  ++a  a-- +a -a  == != >= <= > < 这些运算符号时，此时进行Number隐式类型转换；
```
-0 > +0; // false
-0 < +0; // false
-0 == +0; // true


var a = '12a'; // Number('12a'); ---> NaN
a++; // 当系统检测到++运算后,会自动将a隐式转换为number类型,然后再进行运算
console.log(a); // NaN


var a = '12'; // Number('12');---> 12
a++; // a = 12 + 1;
console.log(a); // 13


// Number('3');---> 3 * 2
var a = '3' * 2; // (* / - %) 如果遇到这些运算符,其中有一个是数字,那么就会把字符串转为number类型
console.log(a); // 6

// 在判断比较运算符的情况下,如果有数字类型,就会将另一数据类型转为Number类型在做比较。
var a = '1' > 2; // false
var b =  1 > '2'; // false
var c = null < 3; // true


var a  = 2 > 1 > 3; 
// 运算步骤:
// 1. 2 > 1 返回true
// 2. 隐式转换Number(true);--> 1 > 3
// 3. 返回false

var a = 2 > 1 == 1;
// 运算步骤:
// 1. 2 > 1 返回true
// 2. 隐式转换Number(true);--> 1 == 1
// 3. 返回true
```

2. String隐式类型转换
- 字符串遇见"+"运算符，进行字符串拼接的操作
```
var a = '1' + 2; // String(2);  '1'+'2' = 12 string
console.log(a); // 12 string
```
- 字符串之间的比较，比较的是ASCII码表中的值
```
var d = 'a' > 'b'; // false
// 因为字符串'a'在ASCII码对应97,'b'是98
```

- ==和!=隐式转换，===不进行隐式转换

==和!=如果存在数字类型，将另一数据类型转换成数字类型(除undefined/null)，然后再对比
```
var a = 1 == '1'; // true --> Number('1'); 1
var a = 1 != '2'; // true

var a = 1 === '1'; // false 全等不进行转换
```
```
var name = '';
if(!name) { // 隐式转换,将字符串隐式转换成boolean类型,然后再去做非(!)运算  Boolean(name)-->Boolean('')-->false-->!false--->true
 	console.log('没姓名');
} else {
	console.log('名字:' + name);
}
```
- NaN和undefined和null
undefined 和 null，说明undefined和null在做==运算的时候，二者不与任何数据类型进行操作运算。
```
// NaN不等于包括自身的任何值
NaN == NaN; // false

var a = undefined > 0; // false
var a = undefined < 0; // false
var a = undefined == 0; // false

var b = null > 0; // false;
var b = null < 0; // false;
var b = null == 0; // false;

// 比较独特的两个比较
var c = null == undefined; // true
var d = null === undefined; // false;
```
- +(正) -(负)也会隐式转换
```
// 隐式转换为数字类型
var num = '123'; 
console.log(+num); // 123
console.log(-num); // -123
// 也就是说-num是number类型,但是typeof打印出来的结果是字符串类型
console.log(typeof(-num)); // number  string
```

- isNaN方法
先通过Number()隐式转换，然后再通过isNaN()方法进行判断；Number(值)-->isNaN(值)-->Boolean值
```
console.log(isNaN('str')); // true
console.log(isNaN(undefined)); // true
console.log(isNaN(null)); // false
console.log(isNaN('12a')); // true
console.log(isNaN(12a)); // Uncaught SyntaxError: Invalid or unexpected token 报错,因为a未被定义
console.log(isNaN(NaN)); // true
```

## parseInt() 方法
parseInt方法的语法格式
parseInt(参数1string，参数2);
  	参数1: 需要转化的数据;将其第一个参数转换为一个字符串(使用toString()方法)，对该字符串进行解析，然后返回一个整数或NaN。开头空白被忽略，不能解析nfinity/-Infinity，返回NaN。
  	参数2: radix进制基底; 例如2为基底，表示被解析的是2进制的数，然后返回十进制整数;

paserInt()方法直接将数据转为整型数据，不会通过Number类型进行转化
```
typeof(parseInt('123')); // 123 number
typeof(parseInt(true)); // NaN number
typeof(parseInt(null)); // NaN number
```
不存在四舍五入的问题，遇到不能转换的字符直接返回
```
typeof(parseInt('3.1459')); // 3 number
typeof(parseInt('3.859')); // 3 number
parseInt('abc'); // NaN
parseInt('abc123'); // NaN
parseInt('123abc'); // 123
parseInt('123/c'); // 123
```
## parseFloat() 方法
parseFloat(参数):
参数1：需要转换的数据
返回值：返回浮点类型的数据
- parseFloat函数将其第一个参数转换为一个字符串(使用toString)，对该字符串进行解析，返回浮点数或NaN;
- parseFloat函数可以解析Infinity或者-Infinity;
- 参数1字符串开头的空白符将会被忽略;

## toFixed
- toFixed(参数)，参数是存在Number类型的隐式转换；参数是保留小数点后数字个数;介于[0-20]之间,不传参数默认0;
- 会进行对数据的四舍五入
```
var num = parseFloat('3.1415926');
var num2 = parseFloat('3.146');
console.log(num.toFixed(2)); // 3.14
console.log(num2.toFixed(2)); // 3.15
```
- toFixed()参数过大会产生大数危机和浮点数精度的问题